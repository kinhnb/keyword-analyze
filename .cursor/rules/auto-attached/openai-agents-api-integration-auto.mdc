---
description: 
globs: "**/api/*.py", "**/routes/*.py", "**/endpoints/*.py", "**/server/*.py"
alwaysApply: false
---
---
description: 
globs: "**/api/*.py", "**/routes/*.py", "**/endpoints/*.py", "**/server/*.py"
alwaysApply: false
---

 # OpenAI Agents SDK API Integration

## Context
- This rule applies to files implementing API integration for OpenAI Agents
- Ensures secure and efficient exposure of agent functionality via APIs
- Critical for production deployments and external system integration

## Critical Rules
- Implement proper request validation with Pydantic models
- Use async handlers for all agent interactions to prevent blocking
- Set appropriate timeouts for agent operations
- Implement proper error handling and status codes
- Secure endpoints with authentication (API keys, OAuth, etc.)
- Sanitize all user inputs before passing to agents
- Implement rate limiting to prevent abuse
- Use structured response formats for consistent client handling
- Include proper logging for debugging and monitoring
- Implement health check endpoints for service monitoring

## Examples

<example>
```python
from fastapi import FastAPI, HTTPException, Depends, Request, status
from fastapi.security import APIKeyHeader
from pydantic import BaseModel, Field
from agents import Agent, Runner, RunConfig
import asyncio
import time
from typing import Dict, Any, Optional, List

# Define request/response models
class AgentRequest(BaseModel):
    query: str = Field(..., description="User query to process")
    context: Optional[Dict[str, Any]] = Field(default={}, description="Additional context")
    timeout: Optional[int] = Field(default=30, description="Timeout in seconds")

class AgentResponse(BaseModel):
    response: str = Field(..., description="Agent response")
    processing_time: float = Field(..., description="Processing time in seconds")
    metadata: Dict[str, Any] = Field(default={}, description="Response metadata")

# Set up security
API_KEY_NAME = "X-API-Key"
api_key_header = APIKeyHeader(name=API_KEY_NAME)

async def verify_api_key(api_key: str = Depends(api_key_header)):
    if api_key != "your-secure-key":  # Use environment variables in production
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid API Key",
        )
    return api_key

# Rate limiting
class RateLimiter:
    def __init__(self, max_calls: int, time_window: int):
        self.max_calls = max_calls
        self.time_window = time_window
        self.calls = []
    
    async def check(self, client_id: str):
        current_time = time.time()
        # Clean expired timestamps
        self.calls = [call for call in self.calls if current_time - call[1] < self.time_window]
        
        # Count calls from this client
        client_calls = [call for call in self.calls if call[0] == client_id]
        
        if len(client_calls) >= self.max_calls:
            raise HTTPException(
                status_code=status.HTTP_429_TOO_MANY_REQUESTS,
                detail=f"Rate limit exceeded: {self.max_calls} calls per {self.time_window} seconds"
            )
        
        self.calls.append((client_id, current_time))

# Initialize rate limiter
rate_limiter = RateLimiter(max_calls=10, time_window=60)

# Create FastAPI app
app = FastAPI(title="Agent API Service")

# Create agent
assistant_agent = Agent(
    name="API Assistant",
    instructions="Provide helpful responses to user queries via API."
)

# Define API endpoints
@app.post("/api/ask", response_model=AgentResponse, dependencies=[Depends(verify_api_key)])
async def ask_agent(request: AgentRequest, req: Request):
    client_id = req.client.host
    await rate_limiter.check(client_id)
    
    start_time = time.time()
    
    try:
        # Run agent with timeout
        result = await Runner.run(
            assistant_agent, 
            request.query,
            context=request.context,
            config=RunConfig(
                timeout_seconds=request.timeout,
                max_turns=5
            )
        )
        
        processing_time = time.time() - start_time
        
        return AgentResponse(
            response=result.final_output,
            processing_time=processing_time,
            metadata={"success": True}
        )
    except asyncio.TimeoutError:
        raise HTTPException(
            status_code=status.HTTP_408_REQUEST_TIMEOUT,
            detail="Agent processing timed out"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e)
        )

# Health check endpoint
@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": time.time()}
```
</example>

<example type="invalid">
```python
from fastapi import FastAPI
from agents import Agent, Runner

# Missing Pydantic models
app = FastAPI()

# Missing security
agent = Agent(
    name="Insecure Assistant",
    instructions="Help users."
)

# Missing error handling and rate limiting
@app.post("/ask")
async def ask_agent(query: str):
    # Direct user input without validation
    # No timeout configuration
    result = await Runner.run(agent, query)
    return {"response": result.final_output}

# No health check endpoint
```
</example>