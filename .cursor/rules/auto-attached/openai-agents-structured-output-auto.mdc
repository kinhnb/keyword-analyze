---
description: 
globs: **/schema/*.py, **/models/*.py, **/output/*.py, **/agents/*.py
alwaysApply: false
---
---
description: 
globs: **/schema/*.py, **/models/*.py, **/output/*.py, **/agents/*.py
alwaysApply: false
---

---
 # OpenAI Agents SDK Structured Output

## Context
- This rule applies to code implementing structured output for OpenAI Agents
- Ensures proper definition, validation, and handling of structured agent responses
- Critical for reliable integration with downstream systems

## Critical Rules
- Define clear output schemas with proper typing
- Use Pydantic models for structured output validation
- Implement proper error handling for malformed outputs
- Include fallback mechanisms for parsing errors
- Avoid loosely structured or untyped outputs
- Document structured output schemas for consumers
- Consider versioning for output schemas
- Include sensible defaults for optional fields
- Implement proper serialization/deserialization for complex data types
- Use consistent naming conventions across schema definitions

## Examples

<example>
```python
from typing import List, Optional, Dict, Any, Union
from enum import Enum
from pydantic import BaseModel, Field, validator
from datetime import datetime
import json
from agents import Agent, StructuredOutput, Runner, RunConfig

# Define enums for controlled vocabularies
class TaskStatus(str, Enum):
    TODO = "todo"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    BLOCKED = "blocked"

class Priority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

# Define nested schema components
class TaskAssignee(BaseModel):
    """Schema for a task assignee."""
    id: str
    name: str
    email: Optional[str] = None

class TaskDependency(BaseModel):
    """Schema for a task dependency."""
    task_id: str
    dependency_type: str = "blocks"  # Default dependency type

# Define the main output schema
class TaskOutput(BaseModel):
    """Schema for task management output."""
    id: str
    title: str
    description: Optional[str] = None
    status: TaskStatus = TaskStatus.TODO
    priority: Priority = Priority.MEDIUM
    assignee: Optional[TaskAssignee] = None
    dependencies: List[TaskDependency] = Field(default_factory=list)
    tags: List[str] = Field(default_factory=list)
    due_date: Optional[datetime] = None
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    @validator("due_date")
    def validate_due_date(cls, v):
        """Validate that due date is not in the past."""
        if v and v < datetime.now():
            raise ValueError("Due date cannot be in the past")
        return v

# Create a structured output agent
def create_task_management_agent():
    agent = Agent(
        name="Task Manager",
        instructions="""You are a task management assistant. 
        Generate structured task information based on user requests.
        For each task request, extract:
        - A unique ID (use a UUID-like format)
        - A clear, concise title
        - A descriptive summary if provided
        - The appropriate status, priority, and assignee if mentioned
        - Any dependencies between tasks
        - Relevant tags for categorization
        - Due dates in ISO format when specified
        
        Always output data in the correct structure, following the schema definition.""",
        output_schema=StructuredOutput[TaskOutput]
    )
    return agent

# Execute and handle the structured output
async def process_task_request(query: str) -> Dict[str, Any]:
    """Process a task-related request and return structured output."""
    try:
        # Create the agent
        agent = create_task_management_agent()
        
        # Execute the agent
        result = await Runner.run(
            agent,
            query,
            config=RunConfig(
                timeout_seconds=30,
                max_turns=5
            )
        )
        
        # Process the structured output
        task_output = result.final_output
        
        # Verify it's the expected type
        if not isinstance(task_output, TaskOutput):
            # This should not happen with proper output_schema, but handle just in case
            raise TypeError(f"Expected TaskOutput but got {type(task_output)}")
        
        # Convert to dictionary for API response
        response = task_output.dict()
        
        # Additional processing for special field types
        # Convert datetime objects to ISO format strings for JSON serialization
        response["created_at"] = task_output.created_at.isoformat()
        response["updated_at"] = task_output.updated_at.isoformat()
        if task_output.due_date:
            response["due_date"] = task_output.due_date.isoformat()
        
        return {
            "status": "success",
            "task": response
        }
        
    except Exception as e:
        # Handle errors, including validation errors from Pydantic
        return {
            "status": "error",
            "error": str(e),
            "fallback": extract_task_fallback(query)  # Implement fallback extraction
        }

# Implementing a fallback mechanism for parsing errors
def extract_task_fallback(query: str) -> Dict[str, Any]:
    """Basic fallback extraction in case structured output fails."""
    # Simple fallback implementation
    fallback_task = {
        "id": f"fallback-{int(time.time())}",
        "title": query[:50] + ("..." if len(query) > 50 else ""),
        "status": "todo",
        "priority": "medium",
        "created_at": datetime.now().isoformat()
    }
    return fallback_task

# Schema version handling
class TaskOutputV2(TaskOutput):
    """V2 of the task schema with additional fields."""
    estimated_hours: Optional[float] = None
    progress_percent: Optional[int] = Field(None, ge=0, le=100)
    
    class Config:
        schema_extra = {
            "version": "2.0",
            "example": {
                "id": "task-123",
                "title": "Implement new feature",
                "status": "in_progress",
                "priority": "high",
                "estimated_hours": 4.5,
                "progress_percent": 60
            }
        }
```
</example>

<example type="invalid">
```python
# Unstructured output with no schema
def create_bad_task_agent():
    agent = Agent(
        name="Bad Task Agent", 
        instructions="Generate task information based on the request."
        # No output schema defined
    )
    return agent

# Using dict instead of proper models
def process_task_poorly(query):
    agent = create_bad_task_agent()
    result = Runner.run_sync(agent, query)
    
    # Attempt to parse unstructured text
    response = result.final_output
    
    # Manual string parsing prone to errors
    lines = response.split("\n")
    task = {}
    for line in lines:
        if ":" in line:
            key, value = line.split(":", 1)
            task[key.strip().lower()] = value.strip()
    
    # No validation of required fields
    # No type conversion
    return task

# Inconsistent error handling
def handle_task_request(query):
    try:
        agent = create_task_management_agent()
        result = Runner.run_sync(agent, query)
        
        # Unsafe access without proper checking
        task = result.final_output
        
        # Manual conversion without validation
        return {
            "id": task.id,
            "title": task.title,
            "due": str(task.due_date) if hasattr(task, "due_date") else None
        }
    except:
        # Overly broad exception handling
        # No specific error information
        return {"error": "Something went wrong"}
```
</example>